# What is {{ $names.os.lower }}?

## Introduction

{{ $names.os.upper }} is an operating system optimized for running [Docker][Docker] containers on embedded devices, with an emphasis on reliability over long periods of operation, as well as a productive developer workflow inspired by the lessons learned while building {{ $names.company.lower }}.

The core insight behind {{ $names.os.lower }} is that Linux containers offer, for the first time, a practical path to using virtualization on embedded devices. VMs and hypervisors have lead to huge leaps in productivity and automation for cloud deployments, but their abstraction of hardware, as well as their resource overhead and lack of hardware support, means that they are not suitable for embedded scenarios. With OS-level virtualization, as implemented for Linux containers, both those objections are lifted for Linux devices, of which there are many in the Internet of Things.

{{ $names.os.upper }} is an operating system built for easy portability to multiple device types (via the [Yocto framework][yocto] and optimized for Linux containers, and Docker in particular. There are many decisions, large and small, we have made to enable that vision, which are present throughout our architecture.

The first version of {{ $names.os.lower }} was developed as part of the {{ $names.company.lower }} platform, and has run on thousands of embedded devices on {{ $names.company.lower }}, deployed in many different contexts for several years. {{ $names.os.lower }} v2 represents the combination of the learnings we extracted over those years, as well as our determination to make {{ $names.os.lower }} a first-class open source project, able to run as an independent operating system, for any context where embedded devices and containers intersect.

We look forward to working with the community to grow and mature {{ $names.os.lower }} into an operating system with even broader device support, a broader operating envelope, and as always, taking advantage of the most modern developments in security and reliability.

## Variants of {{ $names.os.lower }}

Each version of {{ $names.os.lower }} is available in development and production variants, both built from the same source, but with slightly differing feature sets.

|   Version Name   | Variant Type |                                                                                                            Description                                                                                                             |
|:----------------:|:------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| 2.46.1+rev3-prod |  production  |                                                          This is the production version of {{ $names.os.lower }} and should be used for any production fleet deployments.                                                          |
| 2.46.1+rev3-dev  | development  | This is the development version of {{ $names.os.lower }} and should be used when you are developing a new application and want to use the fast [local mode][local-mode] workflow. This variant should never be used in production. |

### Development vs. Production images

__Warning:__ Development images have an exposed Docker socket and enable passwordless root SSH access and should never be used in production.

The development images are recommended while getting started with {{ $names.os.lower }} and building an application. The development images enable a number of useful features while developing, namely:

* Passwordless [SSH access][ssh-host] into {{ $names.os.lower }} on port `22222` as the root user.
* Docker socket exposed on port `2375`, which allows `{{ $names.company.lower }} push` / `build` / `deploy`, that enables remote Docker builds on the target device (see [Deploy to your Fleet][deploy-to-fleet]).
* Getty console attached to tty1 and serial.
* Capable of entering [local mode][local-mode] for rapid development of application containers locally.

__Note:__ Raspberry Pi devices don’t have Getty attached to serial.

Production images disable passwordless root access, and an SSH key must be [added][config-json-ssh] to `config.json` to access a production image using a direct SSH connection. You may still access a production image by tunneling SSH through the {{ $names.company.lower }} VPN via the CLI (using `balena ssh <uuid>`) or the {{ $names.cloud.lower }} [web terminal][ssh-host]. To use SSH via the VPN, you need to have an SSH key configured on your development machine and [added][ssh-key-add] to the {{ $names.cloud.lower }} dashboard.

In both development and production versions of {{ $names.os.lower }}, logs are written to an 8 MB journald RAM buffer in order to avoid wear on the flash storage used by most of the supported boards.

To persist logs on the device, enable persistent logging via the [fleet configuration variable][fleet-configuration] in the {{ $names.cloud.lower }} dashboard, or prior to device provisioning setting the `"persistentLogging": true` [key][config-json-logging] in `config.json`. The logs can be accessed via the host OS at `/var/log/journal`. For versions of {{ $names.os.lower }} < 2.45.0, persistent logs are limited to 8 MB and stored in the state partition of the device. {{ $names.os.upper }} versions >= 2.45.0 store a maximum of 32 MB of persistent logs in the data partition of the device.

Both development and production versions of {{ $names.os.lower }} allow the setting of a custom [hostname][config-json-hostname] via `config.json`, by setting `"hostname": "my-new-hostname"`. Your device will then broadcast (via Avahi) on the network as `my-new-hostname.local`. If you don't set a custom hostname, the device will default to `<short-UUID>.local`. You can also set a custom hostname via the [Supervisor API][supervisor-api] on device.

On production images, nothing is written to tty1, on boot you should only see the {{ $names.company.lower }} logo, and this will persist until your application code takes over the framebuffer. If you would like to replace the {{ $names.company.lower }} logo with your own custom splash logo, then you will need to replace the `splash/resin-logo.png` file that you will find in the [first partition][parition] of the image (boot partition or `resin-boot`) with your own logo.

__Note:__ As it currently stands, plymouth expects the image to be named `resin-logo.png`.

When a {{ $names.os.lower }} image is downloaded from the {{ $names.cloud.lower }} dashboard, it contains a provisioning key that allows devices flashed with the image to be added to a specific application, and a device API key generated. As such, you should handle such images downloaded from {{ $names.cloud.lower }} with care as anyone with access to the image can add a device to your application. You can find out more about the access restrictions of a device API key [here][security].

### Standalone {{ $names.os.lower }}

Images downloaded via the CLI (using `os download`), via [balena.io/os][balena-io-os], or [manually built via Yocto][yocto-build] are the same {{ $names.os.lower }} images as those downloaded from {{ $names.cloud.lower }} but are unconfigured, and will not connect to the {{ $names.cloud.lower }} servers, but still make use of the Supervisor to keep the containers running. This version of {{ $names.os.lower }} is meant as an excellent way to get started with Docker containers on embedded systems, and you can read more about this at [balena.io/os][balena-io-os].

Should you wish to add an unconfigured device to your {{ $names.cloud.lower }} application, you may migrate it using the interactive `balena join` [CLI command][cli-join] or update the `config.json` of an unconfigured device with a configuration file downloaded from the _Add device_ page of the {{ $names.cloud.lower }} dashboard.

## {{ $names.os.upper }} Components

 The {{ $names.os.lower }} userspace packages only provide the bare essentials for running containers, while still offering flexibility. The philosophy is that software and services always default to being in a container unless they are generically useful to all containers, or they absolutely can’t live in a container. The userspace consists of many open source components, but in this section, we will highlight some of the most important services.

![{{ $names.os.upper }} Components](/img/common/balenaos/balenaOS-components.png)

### systemd

[systemd][systemd] is the init system of {{ $names.os.lower }}, and it is responsible for launching and managing all the other services. {{ $names.os.upper }} leverages many of the great features of systemd, such as adjusting OOM scores for critical services and running services in separate mount namespaces. systemd also allows us to manage service dependencies easily.

### Supervisor

The {{ $names.lower.company }} Supervisor is a lightweight container that runs on devices. Its main roles are to ensure your app is running, and keep communications with the {{ $names.cloud.lower }} API server, downloading new application containers and updates to existing containers as you push them in addition to sending logs to your dashboard. It also provides an [API interface][supervisor], which allows you to query the update status and perform certain actions on the device.

### {{ $names.engine.upper }}

[{{ $names.engine.upper}}][balena-engine] is {{ $names.company.lower }}'s modified Docker daemon fork that allows the management and running of application service images, containers, volumes, and networking. {{ $names.engine.upper }} supports container deltas for 10-70x more efficient bandwidth usage, has 3.5x smaller binaries, uses RAM and storage more conservatively, and focuses on atomicity and durability of container pulling.

### NetworkManager and Modem Manager

{{ $names.os.upper }} uses [NetworkManager][network-manager] accompanied by [ModemManager][modem-manager], to deliver a stable and reliable connection to the internet, be it via ethernet, WiFi or cellular modem. Additionally, to make headless configuration of the device’s network easy, there is a `system-connections` folder in the boot partition, which is copied into `/etc/NetworkManager/system-connections`. So any valid NetworkManager connection file can just be dropped into the boot partition before device commissioning.

### Avahi

In order to improve the [development experience][local-mode] of {{ $names.os.lower }}, there is an [Avahi][avahi] daemon that starts advertising the device as `{{ $names.company.lower }}.local` or `<hostname>.local` on boot if the image is a development image.

### Dnsmasq

[Dnsmasq][dnsmasq] manages the nameservers that NetworkManager provides for {{ $names.os.lower }}. NetworkManager discovers the nameservers that can be used, and a binary called `resolvconf` writes them to a tmpfs location, from where Dnsmasq will take over and manage these nameservers to give the user the fastest most responsive DNS resolution.

### chrony

__Note__: {{ $names.os.upper }} versions less than v2.13.0 used systemd-timesyncd for time management.

[chrony][chrony] is used by {{ $names.os.lower }} to keep the system time synchronized.

### OpenVPN

[OpenVPN][open-vpn] is used as the VPN service by {{ $names.os.lower }}, which connects to the {{ $names.cloud.lower }} VPN, allowing a device to be connected to remotely and enabling remote SSH access.

### OpenSSH

__Note__: {{ $names.os.upper }} versions < v2.38.0 use [dropbear][dropbear] as the SSH server and client

[OpenSSH][open-ssh] is used in {{ $names.os.lower }} as the SSH server and client allowing remote login using the SSH protocol.

## Image Partition Layout

![Image partition layout](/img/common/balenaos/image-partition-layout.png)

The first partition, `resin-boot`, holds important boot files according to each board (e.g. kernel image, bootloader image). It also holds the `config.json` file, which is the central point of [configuring {{ $names.os.lower }}][config-json] and defining its behavior. For example using `config.json` you can set your hostname, add SSH keys, allow persistent logging or define custom DNS servers.

`resin-rootA` is the partition that holds the read-only root filesystem; it holds almost everything that {{ $names.os.lower }} is.

`resin-rootB` is an empty partition that is only used when the rootfs is to be updated. We follow the A-B update strategy for  {{ $names.os.lower }} upgrades. Essentially, we have one active partition that is the OS’s current rootfs and one dormant one that is empty. During a {{ $names.os.lower }} [update][hostos-updates] we download the new rootfs to the dormant partition and try to switch them. If the switch is successful the dormant partition becomes the new rootfs, if not, we roll back to the old active partition.

`resin-state` is the partition that holds persistent data, as explained in the [Stateless and Read-only rootfs](#stateless-and-read-only-rootfs) section.

`resin-data` is the storage partition that contains the Supervisor and application containers and volumes.

## Stateless and Read-Only rootFS

{{ $names.os.upper }} comes with a read-only root filesystem, so we can ensure our host OS is stateless, but we still need some data to be persistent over system reboots. We achieve this with a very simple mechanism, i.e. bind mounts.

{{ $names.os.upper }} contains a partition named `resin-state` that is meant to hold all this persistent data. Inside we populate a Linux filesystem hierarchy standard with the rootfs paths that we require to be persistent. After this partition is populated, we are ready to bind mount the respective rootfs paths to this read-write location, thus allowing different components (e.g. `journald`, when persistent logging is enabled) to be able to write data to disk.

A diagram of our read-only rootfs can be seen below:

![Read only rootFS](/img/common/balenaos/read-only-rootfs.png)

## OS Yocto Composition

The OS is composed of multiple Yocto layers. The [Yocto Project](https://www.yoctoproject.org/) build system uses these layers to compile {{ $names.os.lower }} for the various [supported platforms](/reference/hardware/devices/).
This document will not go into detailed explanation about how the [Yocto Project](https://www.yoctoproject.org/) works, but will require from the reader a basic understanding of its internals and release versioning/codename.

| Codename | Yocto Project Version | Release Date | Current Version | Support Level | Poky Version | BitBake branch |
|:--------:|:---------------------:|:------------:|:---------------:|:-------------:|:------------:|:--------------:|
|   Pyro   |          2.3          |   Apr 2017   |                 |  Development  |              |                |
|  Morty   |          2.2          |   Oct 2016   |      2.2.1      |    Stable     |     16.0     |      1.32      |
| Krogoth  |          2.1          |   Apr 2016   |      2.1.2      |    Stable     |     15.0     |      1.30      |
|  Jethro  |          2.0          |   Nov 2015   |      2.0.3      |   Community   |     14.0     |      1.28      |
|   Fido   |          1.8          |   Apr 2015   |      1.8.2      |   Community   |     13.0     |      1.26      |
|  Dizzy   |          1.7          |   Oct 2014   |      1.7.3      |   Community   |     12.0     |      1.24      |
|  Daisy   |          1.6          |   Apr 2014   |      1.6.3      |   Community   |     11.0     |      1.22      |
|   Dora   |          1.5          |   Oct 2013   |      1.5.4      |   Community   |     10.0     |      1.20      |

We will start looking into {{ $names.os.lower }}’s composition from the core of the [Yocto Project](https://www.yoctoproject.org/), i.e. poky. Poky has released a whole bunch of versions and supporting all of them is not in the scope of our OS, but we do try to support its latest versions. This might sound unexpected as we do not currently support poky’s last version (i.e. 2.1/Krogoth), but this is only because we did not need this version yet. We tend to support versions of poky based on what our supported boards require and also do a yearly update to the latest poky version for all the boards that can run that version. Currently we support three poky versions: 2.0/Jethro, 1.8/Fido and 1.6/Daisy.

On top of poky we add the collection of packages from meta-openembedded.
Now that we are done with setting up the build system let’s add Board Support Packages (BSP), these layers are here to provide board-specific configuration and packages (e.g. bootloader, kernel), thus enabling building physical hardware (not emulators). These types of layers are the ones one should be looking for if one wants to add support for a board; if you already have this layer your job should be fairly straightforward, if you do not have it you might be looking into a very cumbersome job.
At this point we have all the bits and pieces in place to build an OS.
The core code of {{ $names.os.lower }} resides in meta-{{ $names.company.lower }}. This layer handles a lot of functionality but the main thing that one should remember now is that here one will find the `resin-image.bb` recipe. This layer also needs a poky version-specific layer to combine with (e.g. meta-{{ $names.company.lower }}-jethro), these two layers will give you the necessary framework for the abstract {{ $names.os.lower }} generation.
Now for the final piece of the puzzle, the board-specific meta-{{ $names.company.lower }} configuration layer. This layer goes hand in hand with a BSP layer, for example for the Raspberry Pi family (i.e. rpi0, rpi1, rpi2, rpi3) that is supported by the meta-raspberrypi BSP, we provide a meta-{{ $names.company.lower }}-raspberrypi layer that configures meta-{{ $names.company.lower }} to the raspberrypi's needs.

Below is a representative example from the Raspberry Pi family, which helps explain [meta-{{ $names.company.lower }}-raspberrypi/conf/samples/bblayers.conf.sample]({{ $links.githubOS }}/balena-raspberrypi/blob/master/layers/meta-balena-raspberrypi/conf/samples/bblayers.conf.sample).

| Layer Name                                  | Repository                                                                    | Description                                                                           |
|---------------------------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|
| meta-{{ $names.company.lower }}             | {{ $links.githubOS }}/meta-balena                                             | This repository enables building {{ $names.os.lower }} for various devices            |
| meta-{{ $names.company.lower }}-jethro      | {{ $links.githubOS }}/meta-balena                                             | This layer enables building {{ $names.os.lower }} for jethro supported BSPs           |
| meta-{{ $names.company.lower }}-raspberrypi | {{ $links.githubOS }}/{{ $names.company.lower }}-raspberrypi                  | Enables building {{ $names.os.lower }} for chosen meta-raspberrypi machines.          |
| meta-raspberrypi                            | https://github.com/agherzan/meta-raspberrypi                                  | This is the general hardware specific BSP overlay for the Raspberry Pi device family. |
| meta-openembedded                           | http://git.openembedded.org/meta-openembedded                                 | Collection of OpenEmbedded layers                                                     |
| meta-openembedded/meta-oe                   | https://github.com/openembedded/meta-openembedded/tree/master/meta-oe         |                                                                                       |
| meta-openembedded/meta-python               | https://github.com/openembedded/meta-openembedded/tree/master/meta-python     | The home of python modules for OpenEmbedded.                                          |
| meta-openembedded/meta-networking           | https://github.com/openembedded/meta-openembedded/tree/master/meta-networking | Central point for networking-relatedpackages and configuration.                       |
| oe-meta-go                                  | https://github.com/mem/oe-meta-go                                             | OpenEmbedded layer for the Go programming language                                    |
| poky/meta-yocto                             | https://git.yoctoproject.org/cgit/cgit.cgi/meta-yocto/                        |                                                                                       |
| poky/meta                                   | https://git.yoctoproject.org/cgit/cgit.cgi/poky/                              | Core functionality and configuration of Yocto Project                                 |

[avahi]:https://wiki.archlinux.org/index.php/Avahi
[balena-engine]:https://www.balena.io/engine/
[balena-io-os]:{{ $links.osSiteUrl }}
[cli-join]:/reference/cli/#join-deviceip
[config-json]:/reference/OS/configuration
[config-json-hostname]:/reference/OS/configuration/#hostname
[config-json-logging]:/reference/OS/configuration/#persistentlogging
[config-json-ssh]:/reference/OS/configuration/#sshkeys
[containerisation]:http://en.wikipedia.org/wiki/Operating_system%E2%80%93level_virtualization
[chrony]:https://chrony.tuxfamily.org/
[deploy-to-fleet]:/learn/deploy/deployment/
[dnsmasq]:https://wiki.archlinux.org/index.php/Dnsmasq
[Docker]:https://www.docker.com/
[Dockerfile]:http://docs.docker.com/reference/builder/
[dropbear]:https://matt.ucc.asn.au/dropbear/dropbear.html
[fleet-configuration]:/learn/manage/configuration/#configuration-variables
[hostos-updates]:/reference/OS/updates/self-service/
[linux]:http://en.wikipedia.org/wiki/Linux
[local-mode]:/learn/develop/local-mode/
[modem-manager]:https://www.freedesktop.org/wiki/Software/ModemManager/
[network-manager]:https://wiki.gnome.org/Projects/NetworkManager
[open-ssh]:https://www.openssh.com/
[open-vpn]:https://community.openvpn.net/openvpn
[partition]:/reference/OS/overview/2.x/#stateless-and-read-only-rootfs
[security]:/learn/welcome/security/#device-access
[ssh-host]:/learn/manage/ssh-access/
[ssh-key-add]:/learn/manage/ssh-access/#add-an-ssh-key-to-balenacloud
[supervisor]:/reference/supervisor/supervisor-api/
[supervisor-api]:/reference/supervisor/supervisor-api/#patch-v1devicehost-config
[systemd]:https://www.freedesktop.org/wiki/Software/systemd/
[yocto]:https://www.yoctoproject.org/
[yocto-build]:{{ $links.osSiteUrl }}/docs/custom-build/
